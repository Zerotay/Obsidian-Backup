# 지라 프로젝트 관리
- 에픽
	- 서버 구축 및 관리
	- 자동 통합 및 배포
- 스토리
	- 없이 가기
- 이슈
	- 젠킨스 브랜치 전략 구상
	- 개발 젠킨스 파이프라인 설계
	- 배포 젠킨스 파이프라인 설계
	- 젠킨스 파이프라인 작성

깃 브랜치 전략 다시 작성
콘피그 서버 검토

# EC2 서버 세팅
![[Pasted image 20240311103713.png]]
무슨 파일이 없다고 하는데 처음 보는 것 같은데 문제는 없는 것인가?

일단 sudo 시 비밀번호 묻지 않게 바꾸기
비밀번호로 ssh 접속가능하게 바꾸기
![[Pasted image 20240311135309.png]]
certbot/certbot 문제가 있다. 
https://thekkom.tistory.com/122
이렇게 해결할 수 있다고 한다. ㅑ
# 배포 실습
1. deploy.sh를 만든다. 이것은 추후에 jenkins 파이프라인 코드로 다시 쓰인다.
2. 누가 블루인지, 그린인지 정한다. 포트 번호를 정하면 될 것 같다.
	1. lsof를 사용한다. 
	2. 둘 다 없을 수도 있다. 그러면 그냥 앞쪽을 블루라 친다.
3. 배포할 도커 컴포즈를 그린으로 정하고 실행한다. 
4. 헬스체크한다.
5. 느징스 포트 정보 바꾸고 다시 리로드한다.
6. 이전 도커 컴포즈는 지운다.
7. 죽었는지 체크하고, 느징스를 통해 접근가능한지 확인한다.

스프링 파일을 하나 세우자


이걸 끝내면? 

# 클라우드 강의

## Kubernetes in Cloud

gcp를 통해 실습을 진행할 것
쿠버네티스는 여러개의 컨테이너를 하나의 시스템으로 묶어서 클러스터라고 부른다.

쿠베 설치 이전에 cni라는 플러그인 설치해야함
cluster network interface.
직접 쓰는 것은 쉽지 않다. 
그래서 확장성과 고가용성을 고려한 프로그램을 managed service라고 부른다.  
그럼에도 인프라 설정을 해줘야만 하는 것이 있다.

이것까지 아울러 인프라 걱정없이 할 수 잇게 해주는 것이 바로 fully managed service.
다른 말로는 serverless라고 표현한다. 내가 관리할 서버는 없기 때문.

클라우드 업체가 제공해주는 인프라를 통해 그냥 가져다 쓰기만 하는 것은 infra as a service. iaas
어플까지 쓰면 paas
서버만 가져다 쓰면 saas
쿠버를 쓴다고 한다면 iaas, paas에 해당하게 된다. 

## 쿠버네티스 개요
여러 개의 서비스가 클러스터로 묶여서 행동
컨테이너화된 애플리케이션 생성

## 쿠버네티스란?
msa - 기능을 잘개 쪼개서 한 기능이 다운되도실행이 가능하게 분산된 환경을 구축한 서버 구조.

- virtualbox - os위에 하이퍼바이저
- vmware - 바로 하이퍼바이저

하이퍼바이저는 자원 공유와 격리의 역할을 한다. 
파티셔닝과는 어떤 차이인가?
파티셔닝은 위에 올라가는 것이 다 같은 os를 공유한다. 
하바는 다 다른 os를 돌릴 수 있다. 

리눅스 위에 컨테이너 런타임을 설치. 예전에는 도커가 표준이었으나, 최근에는 containerd가 표준
각종 프로그램을 돌리는데 있어서 독립적으로 하고 싶었떤 것. 그것이 가상화의 시작
그 기반은 cgroups와 namespace.
리눅스의 이 기능으로 컨테이너 기술을 구현함

msa 구현에 있어서 컨테이너를 쓰는 게 훨씬 효율적이다. 
빠른 배포를 할 수 있도록 일련의 과정을 프로세스화 시키는 것. 
컨테이너를 빌드하고 테스트하는 게 자동 통합
이를 배포하는 게 자동 배포

참고로 msa라고 해서 전부 컨테이너만을 알아야하는 것은 아니다. 이벤트 드리븐도 있음. 
컨테이너 런타임은 하나의 노드에서 작동하게 한다. 
각종 노드의 관리, 배치, 생성 등을 일괄 관리하는 것이 오케스트레이션 툴, 대표적으로 쿠버네티스

쿠버네티스의 특징
- 오픈소스
- 자동화
- 컨테이너 관리
- 선언적 구성
	- 사용자가 맘대로 미리 선언하고 상태를 코드로 정의시켜두면 쿠버는 최대한 들어준다.
	- 쿠버가 맞추는 방식
	- api 접근 방식
- 명령형 구성
	- 위의 것과 대립되는 개념
	- 명령으로 쿠버를 제어하는 것. 실행 중에.

도커 스웜이라고 도커에서 제공하는 오케스트레이션 툴이 있다. 그러나 표준은 쿠버가 먹었다. 

쿠버 객체의 두가지 요소

사용자가 yaml에 내가 원하는 스펙을 정의
쿠버에게 내게 맞춰달라 사양을 api로 제시
그럼 쿠버는 현재 객체 상태가 사양과 일치하는지 확인
일치하지 않을 시에는 사용자가 원하는 상태로 맞춰주는 작업을 수행
- 쿠버 객체
	- 객체 사양
		- 사용자가 정의한 바람직한 상태
	- 객체 상태
		- 쿠버의 현재 상태
		- 사양에 맞춰 작동한다. 
		- 이를 맞추기 위해 계속 모니터링하고 동작함

이게 선언적임을 나타내는 구간

- 아키텍쳐
	- 클러스터
		- 제어영역(control plain)
			- 노드들을 관리
		- 노드
			- 이 노드들을 워커라고 부름

사용자는 쿠버와 kubectl을 통해 쿠버와 상호작용.직접 노드에 접근하지 않는다. 
그걸 하는 게 제어영ㄱ역

그래서 둘로 나누면 컨트롤 플레인, 데이터 플레인이라 부른다. 
데이터 플레인이 노드들의 영역
쿠버네티스는 클러스터 시스템이다!!

제어 영역을 자세히 보자
- kubeapiserver
	- kubectl을 받아주는 서버. 
	- 클러스터의 모든 명령을 수락하는 진입점
- kube-scheduler
	- 여유가 있는 노드를 파악
	- 사용자가 선언할 때 사용할 곳은 스케줄러로 결정됨
	- 사용할 수 있는 공간을 파악.
- etcd
	- 클러스터의 상태를 안정적으로 저장
	- 모든 객체의 상태가 저장됨
	- 사용자가 두개를 요청했는데 실제로 하나만 뜨꼬 있따면?
- kube-controller-manager
	- 사용자의 요청과 클러스터의 상태를 파악
	- 상태를 모니터링하면서 바람직한 상태를 달성하기 위해 변경 시도
- kube-cloud-manager
	- 클라우드 제공업체와 상호작용하는 컨트롤러 관리

이건 gitops와 연관된다. 이러한 선언적 구성 방식.
원하는 상태를 깃에 올려두면 쿠버가 그 상태에 맞춰서 클러스터를 유지시켜준다.

이제 워커노드, 데이터 플레인의 영역을 보자
각 노드들은 컨테이너를 띄울 수 있는 능력이 되어야 한다.
각 노드가 컨테이너 런타임을 활용하 ㄹ수 있어야함
그래서 각 노드는 kubelet이 있따. 그 안에 당연히 containerd가 들어감
그 안에는 클러스터 간 네트워크 연결을 위한 kube-proxy가 잇따.
파드 - 컨테이너의 묶음. 가장 작은단위
쿠버가 배포했따하면 파드가 배포됐다 이해하자.

