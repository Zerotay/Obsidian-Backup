# 배포 파일 작성
![[Pasted image 20240318095623.png]]
도커 컴포즈로 현재 떠 있는 컨테이너를 확인하여 블루를 지정한다.

헬스체크는 총 두번을 거쳐서 한다. 컴포즈를 통해 도커 파일에 지정된 헬스체크를 발동시킨다. 이게 가장 근본적인 헬스체크.

마지막은 느징스 상에서 이뤄진다.

파이썬 서버를 gpu에 올려도 될 듯하다. 그러면 ec2의 부담이 줄어들 것이다. 모델이 돌아가는 서버는 확실히 따로 두는 게 메리트가 있다. 
대신에 시간이 많지 않으므로 파이썬 서버의 무중단 배포는 과감히 포기한다.

무중단 배포 성공!
![[Pasted image 20240318152934.png]]
이런 식으로 짜서, 무중단 배포가 되는 것을 확인했다.

# 젠킨스 설정
이제 모든 준비가 거의 끝났다. 젠킨스로 실제로 배포가 되도록 하면 된다.
아직 개발용만 만들고 배포용은 못 만들었지만, 실질적으로 다른 것은 없기 때문에 크게 어려운 것을 없을 것으로 생각된다. 
그러니 젠킨스로 cicd가 되게 만들기만 하면 일단 되는 것이다.

이번에는 정말 Jenkinsfile까지 활용하고 멀티브랜치 파이프라인을 만들어보자
https://velog.io/@jae_cheol/%EB%A9%80%ED%8B%B0%EB%B8%8C%EB%9E%9C%EC%B9%98-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8
https://creampuffy.tistory.com/202

음 조금 더 찾아봤는데, 브랜치마다 젠킨스파일을 위치시키게 하는 게 골자이다. 근데.. 머지리퀘스트가 되면 상위 브랜치의 젠킨스파일이 결국 하위 브랜치의 것으로 대체되는 꼴이 되어버릴텐데 이러면 무슨 의미가 있는가?
# 스왚메모리 파일 설정
```bash
touch ./swapfile 
sudo fallocate -l 16G ./swapfile 
sudo chmod 600 ./swapfile 
sudo mkswap ./swapfile 
sudo swapon ./swapfile 
echo "swapfile none swap sw 0 0" >> /etc/fstab
free -h ```
생각보다 어렵지 않다. 파일에 메모리를 할당하고, 그 파일을 스왑 메모리로 설정하는 것이다.

# 레디스 설치
![[Pasted image 20240318172008.png]]
그냥 레디스를 설치하면 이슈가 없는데,
도커파일로 설정할 때 이슈가 존재하는 듯하다.

도커파일로 상위에 레이어를 쌓는 것이 문제가 되는 것으로 보인다.
그 이후에는 컨테이너 만들 때 thin layer가 제대로 덮어지지 않고 전부 permission denied가 나온다.
그래서 따로 도커파일을 만들지 않고 그냥 바로 도커허브에서 가져온 이미지를 사용하는 것으로 컴포즈 파일을 수정했다. 

# 클라우드 강의
쿠버네티스에서의 접근 제어 및 보안
쿠버네티스 클러스터 생성
컨테이너화된 애플리케이션 생성

쿠버네티스는 별도의 인증 프로바이더가 없다.

시스템에 아무나 들어와선 안 돼서 신원 확인을 해야 한다
이를 authentication, 인증이라고 한다.
그리고 들어오더라도 들어온 사람마다 시스템 제어 권한이 저마다 달라야 한다.
이를 authorization, 인가라고 한다.

쿠버네티스에서 인증 프로바이더는 없다!
인증 프로바이더는 클라우드 환경에서는 iam이 관리해준다.
Identity and Access Management(IAM).
클라우드에는 이러한 서비스가 존재한다.

인증은 이리 되고, 그럼 클러스터 내부에서 작업하는 것은? 
인가를 해야 하는 것이니까.
파드는 항상 없어질 수있다. 그 정보를 저장해야할 수도 있다. 이는 클러스터 외부에 저장하는 게 바람직할 것이다. 

우리 컴에 데이터는 어떻게 저장하나? 블럭 단위로 저장한다.
그래서 block io라고 한다.
네트워크 스토리지도 존재한다. 나트 같은 장치. 이건 file storage
s3같은 것은 object storage라고 한다.

오브젝 스토리지는 큰 파일을 저장할 수 있다.
우리 컴은 계층적 구조를 가져갈 수 있따.
오브젝은 전부다 수평적으로이뤄져 있다.
폴더가 있는 것처럼 보이나 그건 시뮬레잇된 것이다.
s3같은 건 클라우드가 제공하는 서비스

파드가 저장하려면 클러스터 바깥의 s3같은 놈에 접촉을 해야한다.
그러려면 파드가 그러한 권한이 필요하다.
객체에게 권한을 주기 위해, 쿠버네티스는 service account가 있다.
객체는 그러한 권한을 sa로부터 받고, 실제 인증은 이번에도 iam의 힘을 빌린다.
클라 내부에서는 외부를 못보니까 iam이 도와주는 것.

sso(싱글 사인온) 한번 로그인하면 여러 다른 페이지를 이동할 수 있도록하는 것. 
oauth가 대표적
클라우드 내부에 굳이 인증 프로바이더가 없는 이유가 이런 것.

그래서 클러스터 내부에는 service account, 외부엔 iam이 있다는 걸 기억하자.

쿠버 내부는 쿠버가 제어할 수 있따.
이 안에서는 rbac를 통해 제어한다.
쿠버 외부에서 온 것을 제어할 때는 iam.

api server는 여러 방식으로 인증을 수행할 수 있따.
과거에는 openid연결 토큰, x509, 정적 암호등의 것이 있었따.
근데 보안 이슈가 있어 1.12버전 이후로는 중지됨
현재는 openid를 통해 외부 값에 접근할 수 있다.

iam을 더 털어보자.
플젝을 할 때.
조직이 있다. 이게 도메인이 될 것이다. 
그 안에서 돌아가는 프로젝트들이 있다.
이를 계층적으로 보통 가져간다. 
구글에서 뭔갈 만지면 죄다 프로젝트 안에서 만들어진다.

rbac은?
서비스어카운트는 rbac하기 위한. 객체에게 권한을 주는.
gcp를 보면 iam 드가서 보면 서비스 어카운트들이 있따. 이놈은 쿠버 안 에 있는 놈이 아니다.
aws로 치면 role과 매칭이 된다.

GCP에서 iam으로 일일히 권한을 부여할 수 있다.
클러스터 엔진 어드민 이란 권한은 클러스터를 만들 수는 없다.
클러스털르 만드는 것은 클라우드에 가상머신을 만드는 권한까지 필요하다.
그래서 클러스터를 다루는 권한은 있는데, 클라우드에 대한 권한이 없어서 직접은 못 만드는 것이다. 
쿠버가 노드를 만들 권한이 필요하다.
서비스 어카운트를 제대로 해야 쿠버가 노드를 만들 권한이 생긴다.

쿠버네티스라는 서비스가 권한을 가져야 한다. 사용자는 쿠버에 대한 권한, 쿠버는 클라에 대한 권한이 있어야 한다. 그래야 사용자가 클러스터를 만들 수 있게 된다. 

aws에서. 유저 그룹에게 권한을 줄 수는 있다. 그러나 role을 사용해서 유저에게 주는 게 더 좋다.
롤은 서비스에게도, 사용자에게도, identity(페북, 구글, 그런 인증)에게도 줄 수 있다. 
saml은 조직에서 사용하는 것. 

서비스에 권한을 주면 가령ec2가 s3에 접근하는데 일일히 접근 정보가 필요하거나 그렇지 않게 된다.
rbac는 role based access account
인증 권한이 있어 들어와서 rbac을 거친다.
그럼 거꾸로 나갈 때는? iam의 도움을 거쳐야만 한다. 

irsa. IAM Role for Service Account
eks를 할 때 이 개념을 꼭 알아야 한다

role을 쓰면 서비스에게 권한을 줄 수 있따느 ㄴ것이 핵심이다. 나중에 고통받을 테니 꼭 숙지해두라.

클러스터는 만들 수 있으나, 클러스터가 있을 수 잇는 가상머신 제어 권한이 없다. 그게 서비스 어카운트 권한이 없다고 나오는 것. 
그래서 서비스어카운트 유저라는 것까지 추가해줘야한다.

이 개념을 잘 알아야 한다.
iam으로 쿠버에 들어가고, 쿠버 내 rbac으로 관리된다. 

aws에서 이러한 기능을 해주는 것은 sts라고 부른댄다. 이를 통해 irsa가 되는 것. 

쿠버의 rbac개념
사용자가 있고, 대상 리소스와 동사가 있다. 후자의 둘을 묶어 역할이라 부른다.
aws에서도 role이 있었다. 이것들을 잘 아는 것이 중요하다.
aws에서 권한은 policy
이걸 실제 서비스에 줄 수 있게 바인딩하면 role

어떤 자원에 어떤 동작을 할 수 있는지. 이게 역할
이걸 사용자에게 주는 것은 role binding

클라우드 - 권한 - 바인딩
aws - policy - role
k8s - role - rolebinding
gcp - role - service account
이걸 일일히 기억하기보다는 이 구조를 알자.
누가, 어떤 자원에, 어떤 작업을 할 수 있는지!
인증하고, 인가를 주는 것.

클러스터 수준에서의 role이 있고
파드 수준에서의 role도 있다.

개발, 운영, 테스트 이런 것들을 전부 나누고 싶을 수 도 있따.
이때 namespace를 쓴다.
이 영여겡서 하는 게 일반 role 객체
전체를 하면 cluster role

쿠버 내부의 서비스 어카운트는 파드가 외부 자원에 권한을 줄 때
이건 gcp의 서비스 어카운트와는 다르다

롤바인딩에서 사용자에게 줄 수도 있고, 파드에게 줄 수도 있고.

클러스터를 바인딩할 때는 clusterrolebinding

istio라는 걸 통해 더 세밀하게 보안을 관리할 수도 있다


application packaging

어플리케이션을 배포할 때, 어떤 것들이 필요한가?
쿠버 관점에서 디플로이먼트와 서비스 이걸 쌍으로
서비스는 로드밸런서, 노드포트, 클러스터아이피 이렇게 가능

나중에 앱이 커지면
이런 디플과 서비스를 또 묶음으로 만들고 싶을 것이다.
이 단위부터는 헬름이 된다. 
예전에는 헬름서버라는 게 필요했다.
지금은 헬름 클라이언트만 있으면 된다.
그러면 이 클라는 kuber api server와 통신하면 된다.
헬름의 저장소는 chart repository라고 한다.  

헬름 create하면 chart.yaml에 값이 담긴ㄷ마.ㄴㄴ

프로젝트의 최종 산출물을 보통 아티팩트라 한다.
헬름은 artifact registry에 저장을 해준다.
쿠

