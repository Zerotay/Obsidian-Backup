# 게임 서버
## 게임 통신 방식에 따른 서버 분류
서버를 구분하는데 있어 가장 기본적인 것은 통신 방식. 
플레이어끼리 반드시 실시간 상호소통이 필요한가?
- 게임 플레이가 실시간으로 반드시 통신이 필요한 경우 - 동기적 서버 구현
	- tcp/udp를 이용한 소켓 통신, rpc(remote procedure calls) 사용
	- 재화, 아이템 구매 등의 단순 저장 데이터의 경우 웹 서버 운영
- 실시간 통신이 필요하지 않는 경우 - 비동기 서버 구현
	- stateless한 http 통신을 하는 웹 서버 이용
		- 일반 웹 어플리케이션과 구조가 다름
	- 플레이어와 서버의 단 방향 통신
	- 서버의 수평적 확장이 용이하며 클라이언트 보안에 취약
	- 키우기형, 방치형 등 랭킹 경쟁 류의 모바일 게임

그렇다면 stateful한 서버의 특징은?
- 클라이언트와 1:1 연결이 보장되어야 함
	- 양방향 통신
	- 클라가 서버에 행동을 요청하고 접속한 모든 클라에게 데이터를 보냄(데이터 동기화 broadcast)
	- 모든 클라가 서버에 연결되어 수직적 확장으로 서비스 운영
	- 수평적 확장을 위해서는 각각의 게임 서버를 늘리는 방식
## 포톤 클라우드와 통신 방식
- 포톤 클라우드
	- 유니티 전용 네트워크 엔진
	- Room 기반의 서버 아키텍쳐
	- 소규모 인원이 한 방에서 진행하는 게임에 적합한 엔진
	- 동기화 방식
		- PhotonView
			- Observer pattern으로 설계되어 있음
			- photonView 객체가 오브젝트의 움직임 감시
			- 변경 생길 시 모든 클라에 전송
			- 네트워크 부하가 많이 발생
		- Remote Procedure Calls(RPC) 
			- 게임 안 오브젝트에게 특정 함수를 실행하도록 요청
			- 한 번의 호출로 로컬 상에서 클라의 움직임을 동기화
			- 서버에서 각 로컬에 함수를 요청하는 방식
			- 네트워크 부하 감소
			- 코드 로직이 클라에 들어가서 보안에 취약함

## 소켓 프로그래밍의 이해
- 소켓
	- 네트워크 상에서 돌아가는 두 프로그램의 접속점
	- IP와 port의 조합으로 이뤄진 엔드포인트를 바탕으로 연결
	- 클라의 소켓 연결 요청과 서버의 연결 수락이 이뤄지면 데이터를 양방향으로 주고받을 수 있음
	- 특징
		- 패킷이라는 형식화된 데이터 메모리 단위로 통신
		- 실시간 양방향 통신
		- stateful하여 서버가 클라의 상태를 저장
		- 서버가 메모리에 데이터를 저장하며 통신하는 것도 가능
	- 패킷 데이터 만들기
		- 연결된 클라와 서버가 통신을 주고받기 위한 일종의 데이터 규약
		- 패킷의 공통 헤더와 메시지를 버퍼를 이용하여 확장성 있게 구현
	- 싱글 스레드 소켓 서버
		- 모든 소켓 연결이 하나의 쓰레드에서 이뤄짐
	- 멀티 쓰레드 소켓 서버 
		- 열 개의 소켓이 생기면 열 개의 쓰레드가 생김

# 깃 협업 설정